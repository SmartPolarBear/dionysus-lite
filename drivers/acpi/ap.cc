

#include "drivers/acpi/acpi.h"
#include "drivers/acpi/cpu.h"
#include "drivers/apic/apic.h"

#include "sys/bootmm.h"
#include "sys/memlayout.h"
#include "sys/types.h"
#include "sys/vm.h"

#include "lib/libc/string.h"

// generated by the linker for ap_boot binary
extern uint8_t _binary___build_ap_boot_start[];
extern uint8_t _binary___build_ap_boot_end[];
extern uint8_t _binary___build_ap_boot_size[];

// in boot.S
extern "C" void entry32mp(void);

constexpr uintptr_t AP_CODE_LOAD_ADDR = 0x7000;

extern "C" [[clang::optnone]] void ap_enter(void)
{
    return;
}

[[clang::optnone]] void ap::init_ap(void)
{
    uint8_t *code = reinterpret_cast<decltype(code)>(P2V(AP_CODE_LOAD_ADDR));
    memmove(code, _binary___build_ap_boot_start, (size_t)_binary___build_ap_boot_size);

    for (auto cpu = cpus; cpu != cpus + cpu_count; cpu++)
    {
        if (cpu == cpus + local_apic::get_cpunum())
        {
            continue;
        }

        char *stack = vm::bootmm_alloc();

        *(uint32_t *)(code - 4) = 0x8000; // just enough stack to get us to entry64mp
        *(uint32_t *)(code - 8) = V2P(uintptr_t(entry32mp));
        *(uint64_t *)(code - 16) = (uint64_t)(stack + PAGE_SIZE);

        local_apic::start_ap(cpu->apicid, V2P((uintptr_t)code));
    
        while(cpu->started==false)
            ;
    }
}