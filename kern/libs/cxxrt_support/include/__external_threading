#pragma once

// Imported from zircon kernel
// Previous license:
//
// Copyright 2020 The Fuchsia Authors
//
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT


// libc++'s <atomic> includes this file via <__threading_support>.  It needs
// these types and functions declared, but only for use in interfaces that
// aren't supported in the kernel, so dummy declarations are all they need.

//#include "arch/amd64/lock/arch_spinlock.hpp"

#include <chrono>
#include <limits>
#include <version>

_LIBCPP_BEGIN_NAMESPACE_STD

struct __libcpp_timespec_t
{
	long int tv_sec, tv_nsec;
};

using __libcpp_thread_id = int;

bool __libcpp_thread_id_equal(__libcpp_thread_id, __libcpp_thread_id);
bool __libcpp_thread_id_less(__libcpp_thread_id, __libcpp_thread_id);
__libcpp_thread_id __libcpp_thread_get_current_id();

void __libcpp_thread_sleep_for(chrono::nanoseconds);
void __libcpp_thread_yield();

using __libcpp_condvar_t = uint64_t;
using __libcpp_mutex_t = uint64_t;

static inline void __libcpp_mutex_lock(__libcpp_mutex_t* l)
{
}

static inline void __libcpp_mutex_unlock(__libcpp_mutex_t* l)
{
}

static inline bool __libcpp_mutex_trylock(__libcpp_mutex_t* l)
{
	return true;
}

enum : uint64_t
{
	_LIBCPP_CONDVAR_INITIALIZER = 0,
	_LIBCPP_MUTEX_INITIALIZER = 0
};
static inline void __libcpp_condvar_destroy(void*)
{
}
static inline void __libcpp_mutex_destroy(void*)
{
}



// This macro is used unconditionally in <__threading_support> but defined
// there only conditionally on when <__external_threading> is not used.
#define _LIBCPP_THREAD_ABI_VISIBILITY inline _LIBCPP_INLINE_VISIBILITY

_LIBCPP_END_NAMESPACE_STD
